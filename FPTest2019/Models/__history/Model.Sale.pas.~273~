unit Model.Sale;

interface

uses
  Interfaces.Model.Sale;

  function CreateModelSale: IModelSale;

implementation

uses
  System.SysUtils,
  Helper.MyFuncs,
  Device.FP700X,
  DataModule.Sale,
  DataModule.Items,
  DataModule.Clients,
  View.Message,
  Interfaces.Model.Classes.Sale,
  Model.Classes.Sale,
  Interfaces.Model.Classes.Sale.Detail,
  Model.Classes.Sale.Detail,
  Interfaces.Model.Classes.Sale.Cancellation;

const
  cReturnsAllowedID = -1;

type
  TModelSale = class(TInterfacedObject, IModelSale)

  {$REGION 'Private Methods'}
  private
    function ItemIsValidForSale(const ASaleDetail: IModelClassSaleDetail): Boolean;
    function ItemIsValidForCancellation(const ASaleCancellation: IModelClassSaleCancellation): Boolean;
  {$ENDREGION}


  {$REGION 'Private Fields'}
  private
    FSale: IModelClassSale;

    FReturnsAllowed: Boolean;
  {$ENDREGION}


  {$REGION 'Private Properties Getters/Setters'}
  private

  {$ENDREGION}


  {$REGION 'Private Properties'}
  private

  {$ENDREGION}


  {$REGION 'Interfaced Properties Getters/Setters'}
  public
    function GetSale: IModelClassSale;
  {$ENDREGION}


  {$REGION 'Interfaced Properties'}
  public
    property Sale: IModelClassSale read GetSale;
  {$ENDREGION}


  {$REGION 'Interfaced Methods'}
  public
    // Setup/Teardown
    procedure SetupSale;
    procedure TeardownSale;

    // Sale Actions
    procedure OpenSale;
    procedure RegistrationOfSale;
    procedure RegistrationOfDuplication;
    procedure RegistrationOfCancellation;
    procedure RemoveItem;
    procedure Totals;
    procedure DiscardSale;
    procedure CloseSale;

    // Sale's Payments Updates
    procedure UpdateSaleDue(const ADueDelta: String);
    procedure UpdateSaleCashPayment(const ACashPayment: String);
    procedure UpdateSaleVoucherPayment(const AVoucherPayment: String);
    procedure UpdateSaleCardPayment(const ACardPayment: String);
  {$ENDREGION}


  {$REGION 'Constructors/Destructors'}
  public

  {$ENDREGION}
  end;

function CreateModelSale: IModelSale;
begin
  Result := TModelSale.Create;
end;

{ TModelSale }

{$REGION 'Private Methods'}

function TModelSale.ItemIsValidForSale(const ASaleDetail: IModelClassSaleDetail): Boolean;
begin
  Result := False;

  // Check for Return Allowance
  if (ASaleDetail.Quantity.ToDouble < 0) and (not FReturnsAllowed) then begin
    ViewMessage.ShowBadMessage('ÕÂ Â ‡ÁÂ¯ÂÌÓ ‚˙˘‡ÌÂ ‚ Ú‡ÁË ÔÓ‰‡Ê·‡!');
    Exit;
  end;

  // Check for Return Allowance Toggle
  if ASaleDetail.ItemGID.ToInteger = cReturnsAllowedID then begin
    FReturnsAllowed := True;
    Exit;
  end;

  // Check for positive Due
  if (FSale.Due.ToDouble + ASaleDetail.Total.ToDouble) < -0.009 then begin
    ViewMessage.ShowBadMessagePlus('—¿ÀƒŒ“Œ œŒ Œœ≈–¿÷»ﬂ“¿ Õ≈ “–ﬂ¡¬¿ ƒ¿ ≈ Œ“–»÷¿“≈ÀÕŒ!');
    Exit;
  end;

  Result := True;
end;

function TModelSale.ItemIsValidForCancellation(const ASaleCancellation: IModelClassSaleCancellation): Boolean;
begin
  Result := False;

  if not (ASaleCancellation.Price.ToDouble < 0) then begin
    Exit;
  end;

  // Check for positive Due
  if (FSale.Due.ToDouble + ASaleCancellation.Total.ToDouble) < -0.009 then begin
    ViewMessage.ShowBadMessagePlus('—¿ÀƒŒ“Œ œŒ Œœ≈–¿÷»ﬂ“¿ Õ≈ “–ﬂ¡¬¿ ƒ¿ ≈ Œ“–»÷¿“≈ÀÕŒ!');
    Exit;
  end;

  Result := True;
end;

{$ENDREGION}


{$REGION 'Private Properties Getters/Setters'}

{$ENDREGION}


{$REGION 'Interfaced Properties Getters/Setters'}

function TModelSale.GetSale: IModelClassSale;
begin
  Result := FSale;
end;

{$ENDREGION}


{$REGION 'Interfaced Methods'}

// Setup/Teardown

procedure TModelSale.SetupSale;
begin
  DataModuleItems.RefreshData;

  DataModuleClients.RefreshData;

  DataModuleClients.SelectCommonClient;

  FSale := CreateModelClassSale;

  FReturnsAllowed := False;

  FSale.SetupSale;

  DeviceFP700X.SetupSale(FSale);

  DataModuleSale.SetupSale(FSale);
end;

procedure TModelSale.TeardownSale;
begin
// nop
end;


// Sale Actions

procedure TModelSale.OpenSale;
begin
  // Open Fiscal Receipt
  DeviceFP700X.OpenSale(Sale);

  // Open in MemTable
  DataModuleSale.OpenSale(FSale);

  // Open in Model
  FSale.OpenSale;
end;

procedure TModelSale.RegistrationOfSale;
var
  LSaleDetail: IModelClassSaleDetail;
begin
  LSaleDetail := CreateFromSelectedItemModelClassSaleDetail(
    DataModuleItems.SelectedTYPED,
    DataModuleItems.SelectedID.ToString,
    DataModuleItems.SelectedBARCODE,
    DataModuleItems.SelectedNAME,
    DataModuleItems.SelectedCOEFF.ToString,
    DataModuleItems.SelectedMEASURE,
    FormatFloat('0.000', DataModuleItems.SelectedQUANTITY),
    FormatFloat('0.0000', _Round(DataModuleItems.SelectedVENDORPRICE*DataModuleItems.SelectedCOEFF, 0.0001)),
    FormatFloat('0.00', _Round(DataModuleItems.SelectedCLIENTPRICE*DataModuleItems.SelectedCOEFF, 0.01)),
    DataModuleItems.SelectedDISCOUNT.ToString,
    FSale.GID,
    FSale.SaleUniqueID,
    FSale.CreatedDate,
    FSale.CreatedTime,
    FSale.ClientSurcharge,
    FSale.ClientVIPStatus
  );

  if ItemIsValidForSale(LSaleDetail) then begin
    if LSaleDetail.Quantity.ToDouble > 0 then begin
      // Fiscalization
      DeviceFP700X.RegistrationOfSale(LSaleDetail);

       // Update Due
      UpdateSaleDue(LSaleDetail.Total);

      // Store in MemTable
      DataModuleSale.RegistrationOfSale(LSaleDetail);

      // Store in Model
      FSale.RegistrationOfSale(LSaleDetail);
    end else begin
      // Fiscalization
//      DeviceFP700X.RegistrationOfDiscount(LSaleDetail);

       // Update Due
//      UpdateSaleDue(LSaleDetail.Total);

      // Store in MemTable
//      DataModuleSale.RegistrationOfDiscount(FSaleDetail);

      // Store in Model
//      FSale.RegistrationOfDiscount(FSaleDetail);
    end;
  end;
end;

procedure TModelSale.RegistrationOfDuplication;
var
  LCurrentSaleDetailGID: String;
  LCurrentSaleDetail: IModelClassSaleDetail;
  LSaleDetail: IModelClassSaleDetail;
begin
  LCurrentSaleDetailGID := DataModuleSale.CurrentSaleDetailGID;
  LCurrentSaleDetail := FSale.GetSaleDetailByGID(LCurrentSaleDetailGID);
  if not Assigned(LCurrentSaleDetail) then Exit;
  LSaleDetail := LCurrentSaleDetail.ToSaleDuplication;

//  GetCurrentItemForDuplication;

  if ItemIsValidForSale(LSaleDetail) then begin
    // Fiscalization
    DeviceFP700X.RegistrationOfSale(LSaleDetail);

    // Update Due
    UpdateSaleDue(LSaleDetail.Total);

    // Store in MemTable
    DataModuleSale.RegistrationOfSale(LSaleDetail);

    // Store in Model
    FSale.RegistrationOfSale(LSaleDetail);
  end;
end;

procedure TModelSale.RegistrationOfCancellation;
var
  LCurrentSaleDetailGID: String;
  LCurrentSaleDetail: IModelClassSaleDetail;
  LSaleCancellation: IModelClassSaleCancellation;
begin
  LCurrentSaleDetailGID := DataModuleSale.CurrentSaleDetailGID;
  LCurrentSaleDetail := FSale.GetSaleDetailByGID(LCurrentSaleDetailGID);
  if not Assigned(LCurrentSaleDetail) then Exit;
  LSaleCancellation := LCurrentSaleDetail.ToSaleCancellation;

//  GetCurrentItemForCancelation;

  if ItemIsValidForCancellation(LSaleCancellation) then begin
    // Fiscalization
    DeviceFP700X.RegistrationOfCancelation(LSaleCancellation);

    // Update Due
    UpdateSaleDue(LSaleCancellation.Total);

    // Store in MemTable
    DataModuleSale.RegistrationOfCancelation(LSaleCancellation);

    // Store in Model
    LCurrentSaleDetail.IsCancelled := '‰‡';
    FSale.RegistrationOfCancelation(LSaleCancellation);
  end;
end;

procedure TModelSale.Totals;
begin
  // Fiscalization
  DeviceFP700X.Totals(FSale);

  // Store in MemTable
  DataModuleSale.Totals(FSale);

  // Store in Model
  FSale.Totals;
end;

procedure TModelSale.CloseSale;
begin
  // Fiscalization
  DeviceFP700X.CloseSale(FSale);

  // Close in MemTable
  DataModuleSale.CloseSale(FSale);

  // Close in Model
  FSale.CloseSale;
end;

procedure TModelSale.DiscardSale;
begin
  // Discard in Fiscal Device
  DeviceFP700X.DiscardSale(FSale);

  // Discard in MemTable
  DataModuleSale.DiscardSale(FSale);

  // Discard in Model
  FSale.DiscardSale;
end;


// Sale's Payments Updates

procedure TModelSale.UpdateSaleDue(const ADueDelta: String);
begin
  FSale.Due := FormatFloat('0.00', _Round(FSale.Due.ToDouble + ADueDelta.ToDouble, 0.01));
  FSale.Returned := (FSale.CashPayment.ToDouble + FSale.VoucherPayment.ToDouble + FSale.CardPayment.ToDouble - FSale.Due.ToDouble).ToString;
  DataModuleSale.UpdateSalePayments(FSale);
end;

procedure TModelSale.UpdateSaleCashPayment(const ACashPayment: String);
begin
  FSale.CashPayment := ACashPayment;
  FSale.Returned := (FSale.CashPayment.ToDouble + FSale.VoucherPayment.ToDouble + FSale.CardPayment.ToDouble - FSale.Due.ToDouble).ToString;
  DataModuleSale.UpdateSalePayments(FSale);
end;

procedure TModelSale.UpdateSaleVoucherPayment(const AVoucherPayment: String);
begin
  FSale.VoucherPayment := AVoucherPayment;
  FSale.Returned := (FSale.CashPayment.ToDouble + FSale.VoucherPayment.ToDouble + FSale.CardPayment.ToDouble - FSale.Due.ToDouble).ToString;
  DataModuleSale.UpdateSalePayments(FSale);
end;

procedure TModelSale.UpdateSaleCardPayment(const ACardPayment: String);
begin
  FSale.CardPayment := ACardPayment;
  FSale.Returned := (FSale.CashPayment.ToDouble + FSale.VoucherPayment.ToDouble + FSale.CardPayment.ToDouble - FSale.Due.ToDouble).ToString;
  DataModuleSale.UpdateSalePayments(FSale);
end;

{$ENDREGION}


{$REGION 'Constructors/Destructors'}

{$ENDREGION}

end.
