unit Model.Reversal;

interface

uses
  Interfaces.Model.Reversal;

  function CreateModelReversal: IModelReversal;

implementation

uses
  System.SysUtils,
  Helper.MyFuncs,
  Device.FP700X,
  DataModule.Sale,
  DataModule.Items,
  DataModule.Clients,
  View.Message,
  Interfaces.Model.Classes.Sale,
  Model.Classes.Sale,
  Interfaces.Model.Classes.Sale.Detail,
  Model.Classes.Sale.Detail,
  Interfaces.Model.Classes.Sale.Reversal;

type
  TModelReversal = class(TInterfacedObject, IModelReversal)

  {$REGION 'Private Methods'}
  private
    function ItemIsValidForReversal(const ASaleDetail: IModelClassSaleDetail): Boolean;
  {$ENDREGION}


  {$REGION 'Private Fields'}
  private
    FSale: IModelClassSale;
  {$ENDREGION}


  {$REGION 'Private Properties Getters/Setters'}
  private

  {$ENDREGION}


  {$REGION 'Private Properties'}
  private

  {$ENDREGION}


  {$REGION 'Interfaced Properties Getters/Setters'}
  public
    function GetSale: IModelClassSale;
    procedure SetSale(const AValue: IModelClassSale);
  {$ENDREGION}


  {$REGION 'Interfaced Properties'}
  public
    property Sale: IModelClassSale read GetSale write SetSale;
  {$ENDREGION}


  {$REGION 'Interfaced Methods'}
  public
    // Setup/Teardown
    procedure SetupReversal;
    procedure TeardownReversal;

    // Reversal Actions
    procedure OpenReversal;
    procedure RegistrationOfReversal;
    procedure Totals;
    procedure DiscardReversal;
    procedure CloseReversal;

    // Reversal's Payments Updates
    procedure UpdateReversalDue(const ADueDelta: String);
  {$ENDREGION}


  {$REGION 'Constructors/Destructors'}
  public

  {$ENDREGION}
  end;

function CreateModelReversal: IModelReversal;
begin
  Result := TModelReversal.Create;
end;

{ TModelReversal }

{$REGION 'Private Methods'}

function TModelReversal.ItemIsValidForReversal(const ASaleDetail: IModelClassSaleDetail): Boolean;
begin
//  Result := False;
//
//  // Check for positive Due
//  if (FSale.Due.ToDouble + ASaleDetail.Total.ToDouble) < -0.009 then begin
//    ViewMessage.ShowBadMessagePlus('ÑÀËÄÎÒÎ ÏÎ ÎÏÅÐÀÖÈßÒÀ ÍÅ ÒÐßÁÂÀ ÄÀ Å ÎÒÐÈÖÀÒÅËÍÎ!');
//    Exit;
//  end;

  Result := True;
end;

{$ENDREGION}


{$REGION 'Private Properties Getters/Setters'}

{$ENDREGION}


{$REGION 'Interfaced Properties Getters/Setters'}

function TModelReversal.GetSale: IModelClassSale;
begin
  Result := FSale;
end;

procedure TModelReversal.SetSale(const AValue: IModelClassSale);
begin
  FSale := AValue;
end;

{$ENDREGION}


{$REGION 'Interfaced Methods'}

// Setup/Teardown

procedure TModelReversal.SetupReversal;
begin
  FSale := CreateFromFileModelClassSale(DataModuleSale.FDMemTableSaleGID.AsString, DataModuleSale.FDMemTableSaleCreatedDate.AsString);
  DataModuleSale.SetupReversal(FSale);
end;

procedure TModelReversal.TeardownReversal;
begin
// nop
end;


// Reversal Actions

procedure TModelReversal.OpenReversal;
begin
  // Open Fiscal Receipt
  DeviceFP700X.OpenReversal(FSale);

  // Open in MemTable
  DataModuleSale.OpenReversal(FSale);

  // Open in Model
  FSale.OpenReversal;
end;

procedure TModelReversal.RegistrationOfReversal;
var
  LCurrentSaleDetailGID: String;
  LCurrentSaleDetail: IModelClassSaleDetail;
  LSaleReversal: IModelClassSaleReversal;
begin
  LCurrentSaleDetailGID := DataModuleSale.CurrentSaleDetailGID;
  LCurrentSaleDetail := FSale.GetSaleDetailByGID(LCurrentSaleDetailGID);
  if not Assigned(LCurrentSaleDetail) then Exit;
  if LCurrentSaleDetail.IsCancelled = 'äà' then Exit;

  LSaleReversal := LCurrentSaleDetail.ToSaleReversal;
  LSaleReversal.FiscalDeviceID := FSale.FiscalDeviceID;
  LSaleReversal.CompletedDate := FSale.CompletedDate;
  LSaleReversal.CompletedTime := FSale.CompletedTime;

  if ItemIsValidForReversal(LSaleReversal) then begin
    // Fiscalization
    DeviceFP700X.RegistrationOfReversal(LSaleReversal);

    // Update Due
    UpdateSaleDue(LSaleReversal.Total);

    // Store in MemTable
    DataModuleSale.RegistrationOfReversal(LSaleReversal);

    // Store in Model
    LCurrentSaleDetail.IsCancelled := 'äà';
    LCurrentSaleDetail.UpdateInDataSet;
    FSale.RegistrationOfReversal(LSaleReversal);
  end;
end;

procedure TModelReversal.Totals;
begin
  // Fiscalization
//  DeviceFP700X.Totals(FSale);

  // Store in MemTable
//  DataModuleSale.Totals(FSale);

  // Store in Model
//  FSale.Totals;
end;

procedure TModelReversal.CloseReversal;
begin
  // Fiscalization
//  DeviceFP700X.CloseReversal(FSale);

  // Close in MemTable
//  DataModuleSale.CloseReversal(FSale);

  // Close in Model
//  FSale.CloseReversal;
end;

procedure TModelReversal.DiscardReversal;
begin
  // Discard in Fiscal Device
//  DeviceFP700X.DiscardReversal(FSale);

  // Discard in MemTable
//  DataModuleSale.DiscardReversal(FSale);

  // Discard in Model
//  FSale.DiscardReversal;
end;


// Reversal's Payments Updates

procedure TModelReversal.UpdateReversalDue(const ADueDelta: String);
begin
//  FReversal.Due := FormatFloat('0.00', _Round(FReversal.Due.ToDouble + ADueDelta.ToDouble, 0.01));
//  DataModuleReversal.UpdateReversalPayments(FReversal);
end;

{$ENDREGION}


{$REGION 'Constructors/Destructors'}

{$ENDREGION}

end.
